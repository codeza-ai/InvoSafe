import sodium from "libsodium-wrappers-sumo";
import { bytes, fromB64, toB64 } from "@/lib/utils";
/**
 * Encrypt the given data using libsodium's secretstream APIs after breaking it
 * into {@link streamEncryptionChunkSize} chunks.
 *
 * Use {@link decryptStreamBytes} to decrypt the result.
 *
 * Unlike initChunkDecryption/ encryptFileChunk, this function
 * processes all the chunks at once in a single call to this function.
 *
 * @param data The data to encrypt.
 *
 * @returns The encrypted bytes ({@link Uint8Array}) and the decryption header
 * (as a base64 string).
 *
 * - See: [Note: 3 forms of encryption (Box | Blob | Stream)].
 *
 * - See: https://doc.libsodium.org/secret-key_cryptography/secretstream
 */
export interface EncryptedFile {
  /**
   * The encrypted data.
   */
  encryptedData: Uint8Array;
  /**
   * A base64 string containing the decryption header.
   *
   * While the exact contents of the header are libsodium's internal details,
   * it effectively contains a random nonce generated by libsodium. It does
   * not need to be secret, but it is required to decrypt the data.
   */
  decryptionHeader: string;
}

// Chunk size for stream encryption/decryption.
// This is the size of each chunk that will be encrypted/decrypted in a single
// call to encryptStreamBytes or decryptStreamBytes.
export const streamEncryptionChunkSize = 4 * 1024 * 1024;


// Merge multiple Uint8Arrays into a single Uint8Array.
// This is a more efficient alternative to using Array.prototype.concat.
export const mergeUint8Arrays = (as: Uint8Array[]): Uint8Array => {
  // A longer but better performing replacement of
  // new Uint8Array(as.reduce((acc, x) => acc.concat(...x), []))

  const len = as.reduce((len, xs) => len + xs.length, 0);
  const result = new Uint8Array(len);
  as.reduce((n, xs) => (result.set(xs, n), n + xs.length), 0);
  return result;
};

export const encryptStreamBytes = async (
    data: Uint8Array,
    key: string | Uint8Array,
): Promise<EncryptedFile> => {
    await sodium.ready;

    const keyBytes = await bytes(key);
    const initPushResult =
        sodium.crypto_secretstream_xchacha20poly1305_init_push(keyBytes);
    const [pushState, header] = [initPushResult.state, initPushResult.header];
    let bytesRead = 0;
    let tag = sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;

    const encryptedChunks = [];

    while (tag !== sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL) {
        let chunkSize = streamEncryptionChunkSize;
        if (bytesRead + chunkSize >= data.length) {
            chunkSize = data.length - bytesRead;
            tag = sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL;
        }

        const buffer = data.slice(bytesRead, bytesRead + chunkSize);
        bytesRead += chunkSize;
        const pushResult = sodium.crypto_secretstream_xchacha20poly1305_push(
            pushState,
            buffer,
            null,
            tag,
        );
        encryptedChunks.push(pushResult);
    }
    return {
        encryptedData: mergeUint8Arrays(encryptedChunks),
        decryptionHeader: await toB64(header),
    };
};

/**
 * Decrypt an encrypted Blob/ArrayBuffer (our container format) using passphrase.
 * Returns a Blob of the original PDF.
 */
export const decryptStreamBytes = async (
  { encryptedData, decryptionHeader }: EncryptedFile,
  key: string | Uint8Array
): Promise<Uint8Array> => {
  await sodium.ready;
  const pullState = sodium.crypto_secretstream_xchacha20poly1305_init_pull(
    await fromB64(decryptionHeader),
    await bytes(key)
  );
  const decryptionChunkSize =
    streamEncryptionChunkSize +
    sodium.crypto_secretstream_xchacha20poly1305_ABYTES;
  let bytesRead = 0;
  const decryptedChunks = [];
  let tag = sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;
  while (tag !== sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL) {
    let chunkSize = decryptionChunkSize;
    if (bytesRead + chunkSize > encryptedData.length) {
      chunkSize = encryptedData.length - bytesRead;
    }
    const buffer = encryptedData.slice(bytesRead, bytesRead + chunkSize);
    const pullResult = sodium.crypto_secretstream_xchacha20poly1305_pull(
      pullState,
      buffer
    );
    decryptedChunks.push(pullResult.message);
    tag = pullResult.tag;
    bytesRead += chunkSize;
  }
  return mergeUint8Arrays(decryptedChunks);
};

// Generate a random key for Blob/Stream encryption.
export const generateBlobOrStreamKey = async () => {
  await sodium.ready;
  return toB64(sodium.crypto_secretstream_xchacha20poly1305_keygen());
};